package goml

// Empty takes a slice and returns true if it's empty, else it returns false
func Empty[T any](xs []T) bool {
	return len(xs) == 0
}

// Tail takes a slice and returns all but the first element in a new slice
func Tail[T any](xs []T) []T {
	if !Empty(xs) {
		return xs[1:]
	}
	return []T{}
}

// Length takes a slice and returns its length
func Length[T any](xs []T) int {
	if Empty(xs) {
		return 0
	}
	return 1 + Length(Tail(xs))
}

// Head takes a slice and returns the first element or if empty, its zero value
func Head[T any](xs []T) T {
	if Empty(xs) {
		var x T
		return x
	}
	return xs[0]
}

// Drop removes the first n elements from a slice
func Drop[T any](n int, xs []T) []T {
	if n == 0 {
		return xs
	} else if Empty(xs) {
		return []T{}
	}
	return Drop(n-1, Tail(xs))
}

// Take retains the first n elements of a slice
func Take[T any](n int, xs []T) []T {
	if n == 0 {
		return []T{}
	} else if Empty(xs) {
		return []T{}
	}
	return Cons(Head(xs), Take(n-1, Tail(xs)))
}

// Last returns the last element of a slice
func Last[T any](xs []T) T {
	h := Head(xs)
	t := Tail(xs)
	if Empty(t) {
		return h
	}
	return Last(t)
}

// Init returns all but the last element of a slice
func Init[T any](xs []T) []T {
	h := Head(xs)
	t := Tail(xs)
	if Empty(t) {
		return []T{}
	}
	return Cons(h, Init(t))
}

// Cons prefixes a slice with a value returning a new slice
func Cons[T any](x T, xs []T) []T {
	return append([]T{x}, xs...)
}

// Concat joins two slices returning a new slice
func Concat[T any](xs, ys []T) []T {
	return append(append([]T{}, xs...), ys...)
}

// Reverse reverses the order of the elements of a slice, returning a new slice
func Reverse[T any](xs []T) []T {
	if Empty(xs) {
		return xs
	}
	return Concat(Reverse(Tail(xs)), []T{ Head(xs) })
}

// Filter applies a bool function to a slice, returning a new slice comprised
// of elements that the function returned true for
func Filter[T any](f func(T) bool, xs []T) []T {
	if Empty(xs) {
		return xs
	}
	h := Head(xs)
	t := Tail(xs)
	if f(h) {
		return Cons(h, Filter(f, t))
	} else {
		return Filter(f, t)
	}
}

// Map transforms a slice by applying a function to every element, returning a
// new slice
func Map[T1, T2 any](f func(T1) T2, xs []T1) []T2 {
	if Empty(xs) {
		return []T2{}
	}
	return Cons(f(Head(xs)), Map(f, Tail(xs)))
}
